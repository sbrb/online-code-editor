{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var htmlConfig = {\n    autoSelfClosers: {\n      'area': true,\n      'base': true,\n      'br': true,\n      'col': true,\n      'command': true,\n      'embed': true,\n      'frame': true,\n      'hr': true,\n      'img': true,\n      'input': true,\n      'keygen': true,\n      'link': true,\n      'meta': true,\n      'param': true,\n      'source': true,\n      'track': true,\n      'wbr': true,\n      'menuitem': true\n    },\n    implicitlyClosed: {\n      'dd': true,\n      'li': true,\n      'optgroup': true,\n      'option': true,\n      'p': true,\n      'rp': true,\n      'rt': true,\n      'tbody': true,\n      'td': true,\n      'tfoot': true,\n      'th': true,\n      'tr': true\n    },\n    contextGrabbers: {\n      'dd': {\n        'dd': true,\n        'dt': true\n      },\n      'dt': {\n        'dd': true,\n        'dt': true\n      },\n      'li': {\n        'li': true\n      },\n      'option': {\n        'option': true,\n        'optgroup': true\n      },\n      'optgroup': {\n        'optgroup': true\n      },\n      'p': {\n        'address': true,\n        'article': true,\n        'aside': true,\n        'blockquote': true,\n        'dir': true,\n        'div': true,\n        'dl': true,\n        'fieldset': true,\n        'footer': true,\n        'form': true,\n        'h1': true,\n        'h2': true,\n        'h3': true,\n        'h4': true,\n        'h5': true,\n        'h6': true,\n        'header': true,\n        'hgroup': true,\n        'hr': true,\n        'menu': true,\n        'nav': true,\n        'ol': true,\n        'p': true,\n        'pre': true,\n        'section': true,\n        'table': true,\n        'ul': true\n      },\n      'rp': {\n        'rp': true,\n        'rt': true\n      },\n      'rt': {\n        'rp': true,\n        'rt': true\n      },\n      'tbody': {\n        'tbody': true,\n        'tfoot': true\n      },\n      'td': {\n        'td': true,\n        'th': true\n      },\n      'tfoot': {\n        'tbody': true\n      },\n      'th': {\n        'td': true,\n        'th': true\n      },\n      'thead': {\n        'tbody': true,\n        'tfoot': true\n      },\n      'tr': {\n        'tr': true\n      }\n    },\n    doNotIndent: {\n      \"pre\": true\n    },\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  };\n  var xmlConfig = {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    allowMissingTagName: false,\n    caseFold: false\n  };\n  CodeMirror.defineMode(\"xml\", function (editorConf, config_) {\n    var indentUnit = editorConf.indentUnit;\n    var config = {};\n    var defaults = config_.htmlMode ? htmlConfig : xmlConfig;\n    for (var prop in defaults) config[prop] = defaults[prop];\n    for (var prop in config_) config[prop] = config_[prop];\n\n    // Return variables for tokenizers\n    var type, setStyle;\n    function inText(stream, state) {\n      function chain(parser) {\n        state.tokenize = parser;\n        return parser(stream, state);\n      }\n      var ch = stream.next();\n      if (ch == \"<\") {\n        if (stream.eat(\"!\")) {\n          if (stream.eat(\"[\")) {\n            if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));else return null;\n          } else if (stream.match(\"--\")) {\n            return chain(inBlock(\"comment\", \"-->\"));\n          } else if (stream.match(\"DOCTYPE\", true, true)) {\n            stream.eatWhile(/[\\w\\._\\-]/);\n            return chain(doctype(1));\n          } else {\n            return null;\n          }\n        } else if (stream.eat(\"?\")) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          state.tokenize = inBlock(\"meta\", \"?>\");\n          return \"meta\";\n        } else {\n          type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n          state.tokenize = inTag;\n          return \"tag bracket\";\n        }\n      } else if (ch == \"&\") {\n        var ok;\n        if (stream.eat(\"#\")) {\n          if (stream.eat(\"x\")) {\n            ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n          } else {\n            ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n          }\n        } else {\n          ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n        }\n        return ok ? \"atom\" : \"error\";\n      } else {\n        stream.eatWhile(/[^&<]/);\n        return null;\n      }\n    }\n    inText.isInText = true;\n    function inTag(stream, state) {\n      var ch = stream.next();\n      if (ch == \">\" || ch == \"/\" && stream.eat(\">\")) {\n        state.tokenize = inText;\n        type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n        return \"tag bracket\";\n      } else if (ch == \"=\") {\n        type = \"equals\";\n        return null;\n      } else if (ch == \"<\") {\n        state.tokenize = inText;\n        state.state = baseState;\n        state.tagName = state.tagStart = null;\n        var next = state.tokenize(stream, state);\n        return next ? next + \" tag error\" : \"tag error\";\n      } else if (/[\\'\\\"]/.test(ch)) {\n        state.tokenize = inAttribute(ch);\n        state.stringStartCol = stream.column();\n        return state.tokenize(stream, state);\n      } else {\n        stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n        return \"word\";\n      }\n    }\n    function inAttribute(quote) {\n      var closure = function closure(stream, state) {\n        while (!stream.eol()) {\n          if (stream.next() == quote) {\n            state.tokenize = inTag;\n            break;\n          }\n        }\n        return \"string\";\n      };\n      closure.isInAttribute = true;\n      return closure;\n    }\n    function inBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = inText;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      };\n    }\n    function doctype(depth) {\n      return function (stream, state) {\n        var ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == \"<\") {\n            state.tokenize = doctype(depth + 1);\n            return state.tokenize(stream, state);\n          } else if (ch == \">\") {\n            if (depth == 1) {\n              state.tokenize = inText;\n              break;\n            } else {\n              state.tokenize = doctype(depth - 1);\n              return state.tokenize(stream, state);\n            }\n          }\n        }\n        return \"meta\";\n      };\n    }\n    function Context(state, tagName, startOfLine) {\n      this.prev = state.context;\n      this.tagName = tagName || \"\";\n      this.indent = state.indented;\n      this.startOfLine = startOfLine;\n      if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;\n    }\n    function popContext(state) {\n      if (state.context) state.context = state.context.prev;\n    }\n    function maybePopContext(state, nextTagName) {\n      var parentTagName;\n      while (true) {\n        if (!state.context) {\n          return;\n        }\n        parentTagName = state.context.tagName;\n        if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n          return;\n        }\n        popContext(state);\n      }\n    }\n    function baseState(type, stream, state) {\n      if (type == \"openTag\") {\n        state.tagStart = stream.column();\n        return tagNameState;\n      } else if (type == \"closeTag\") {\n        return closeTagNameState;\n      } else {\n        return baseState;\n      }\n    }\n    function tagNameState(type, stream, state) {\n      if (type == \"word\") {\n        state.tagName = stream.current();\n        setStyle = \"tag\";\n        return attrState;\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return attrState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return tagNameState;\n      }\n    }\n    function closeTagNameState(type, stream, state) {\n      if (type == \"word\") {\n        var tagName = stream.current();\n        if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);\n        if (state.context && state.context.tagName == tagName || config.matchClosing === false) {\n          setStyle = \"tag\";\n          return closeState;\n        } else {\n          setStyle = \"tag error\";\n          return closeStateErr;\n        }\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return closeState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return closeStateErr;\n      }\n    }\n    function closeState(type, _stream, state) {\n      if (type != \"endTag\") {\n        setStyle = \"error\";\n        return closeState;\n      }\n      popContext(state);\n      return baseState;\n    }\n    function closeStateErr(type, stream, state) {\n      setStyle = \"error\";\n      return closeState(type, stream, state);\n    }\n    function attrState(type, _stream, state) {\n      if (type == \"word\") {\n        setStyle = \"attribute\";\n        return attrEqState;\n      } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n        var tagName = state.tagName,\n          tagStart = state.tagStart;\n        state.tagName = state.tagStart = null;\n        if (type == \"selfcloseTag\" || config.autoSelfClosers.hasOwnProperty(tagName)) {\n          maybePopContext(state, tagName);\n        } else {\n          maybePopContext(state, tagName);\n          state.context = new Context(state, tagName, tagStart == state.indented);\n        }\n        return baseState;\n      }\n      setStyle = \"error\";\n      return attrState;\n    }\n    function attrEqState(type, stream, state) {\n      if (type == \"equals\") return attrValueState;\n      if (!config.allowMissing) setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n    function attrValueState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      if (type == \"word\" && config.allowUnquoted) {\n        setStyle = \"string\";\n        return attrState;\n      }\n      setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n    function attrContinuedState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      return attrState(type, stream, state);\n    }\n    return {\n      startState: function startState(baseIndent) {\n        var state = {\n          tokenize: inText,\n          state: baseState,\n          indented: baseIndent || 0,\n          tagName: null,\n          tagStart: null,\n          context: null\n        };\n        if (baseIndent != null) state.baseIndent = baseIndent;\n        return state;\n      },\n      token: function token(stream, state) {\n        if (!state.tagName && stream.sol()) state.indented = stream.indentation();\n        if (stream.eatSpace()) return null;\n        type = null;\n        var style = state.tokenize(stream, state);\n        if ((style || type) && style != \"comment\") {\n          setStyle = null;\n          state.state = state.state(type || style, stream, state);\n          if (setStyle) style = setStyle == \"error\" ? style + \" error\" : setStyle;\n        }\n        return style;\n      },\n      indent: function indent(state, textAfter, fullLine) {\n        var context = state.context;\n        // Indent multi-line strings (e.g. css).\n        if (state.tokenize.isInAttribute) {\n          if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;\n        }\n        if (context && context.noIndent) return CodeMirror.Pass;\n        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n        // Indent the starts of attribute names.\n        if (state.tagName) {\n          if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n        }\n        if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n        var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n        if (tagAfter && tagAfter[1]) {\n          // Closing tag spotted\n          while (context) {\n            if (context.tagName == tagAfter[2]) {\n              context = context.prev;\n              break;\n            } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n              context = context.prev;\n            } else {\n              break;\n            }\n          }\n        } else if (tagAfter) {\n          // Opening tag spotted\n          while (context) {\n            var grabbers = config.contextGrabbers[context.tagName];\n            if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;\n          }\n        }\n        while (context && context.prev && !context.startOfLine) context = context.prev;\n        if (context) return context.indent + indentUnit;else return state.baseIndent || 0;\n      },\n      electricInput: /<\\/[\\s\\w:]+>$/,\n      blockCommentStart: \"<!--\",\n      blockCommentEnd: \"-->\",\n      configuration: config.htmlMode ? \"html\" : \"xml\",\n      helperType: config.htmlMode ? \"html\" : \"xml\",\n      skipAttribute: function skipAttribute(state) {\n        if (state.state == attrValueState) state.state = attrState;\n      },\n      xmlCurrentTag: function xmlCurrentTag(state) {\n        return state.tagName ? {\n          name: state.tagName,\n          close: state.type == \"closeTag\"\n        } : null;\n      },\n      xmlCurrentContext: function xmlCurrentContext(state) {\n        var context = [];\n        for (var cx = state.context; cx; cx = cx.prev) context.push(cx.tagName);\n        return context.reverse();\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/xml\", \"xml\");\n  CodeMirror.defineMIME(\"application/xml\", \"xml\");\n  if (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\")) CodeMirror.defineMIME(\"text/html\", {\n    name: \"xml\",\n    htmlMode: true\n  });\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","htmlConfig","autoSelfClosers","implicitlyClosed","contextGrabbers","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","allowMissingTagName","defineMode","editorConf","config_","indentUnit","config","defaults","htmlMode","prop","type","setStyle","inText","stream","state","chain","parser","tokenize","ch","next","eat","match","inBlock","eatWhile","doctype","inTag","ok","isInText","baseState","tagName","tagStart","test","inAttribute","stringStartCol","column","quote","closure","eol","isInAttribute","style","terminator","depth","Context","startOfLine","prev","context","indent","indented","hasOwnProperty","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","current","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","startState","baseIndent","token","sol","indentation","eatSpace","textAfter","fullLine","Pass","length","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","exec","grabbers","electricInput","blockCommentStart","blockCommentEnd","configuration","helperType","skipAttribute","xmlCurrentTag","name","close","xmlCurrentContext","cx","push","reverse","defineMIME","mimeModes"],"sources":["C:/Users/SHAYAN BISWAS/Desktop/cv/online-code-editor/node_modules/codemirror/mode/xml/xml.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName || \"\";\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}